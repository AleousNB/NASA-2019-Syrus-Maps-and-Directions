using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TestScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        //creating objects to represent as nodes
        for (int x = -50; x <= 50; x+=10)
        {
            for (int y = -50; y <= 5; y+=10)
            {
                GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                sphere.transform.position = new Vector3(x, y, 0);
            }
        }

        //creating lines to represent edges
        LineRenderer line = new GameObject().AddComponent<LineRenderer>();
        line.useWorldSpace = true;
        line.startWidth = 0.10f;
        line.endWidth = 0.10f;
        line.SetPosition(0, new Vector3(0, 0, 0));
        line.SetPosition(0, new Vector3(0, 5, 10));

        int[] minDists = dijkstra(adjMatrix, numNodes, sourceIndex);
        for (int i = 0; i < numNodes; i++)
        {
            Debug.Log("Shortest Distance from node " + sourceIndex + " to " + i + ": " + minDists[i]);
        }

    }
    //C# implementation of Dijkstra's Algo
    int numNodes = 4;
    int sourceIndex = 0;
    //representation of graph's weighted edges by adjacency matrix
    //0 same as infinite in this case to represent non-existent edges
    int[,] adjMatrix = new int[,]
    {
            {0,7,2,30},
            {7,0,1,3 },
            {2,1,0,9 },
            {30,3,9,0}
    };


    //pseudo-code 
    //all dist values start at infinity
    //set source distance = 0; (Distance from itself is 0)

    //while all of (hasBeenChecked[] == false)
    //  select node with shortest distance from source that has not been checked
    //  set that current node as checked
    //  for all nodes
    //      if (node == unchecked)
    //          if( (curNodDist + adjMatrixDist) < dist)
    //              dist = curNodDist + adjMatrixDist

    //NOTE: can use for loop instead of while since each iteration of that loop will create one permanent dist value
    //so we now that the loop should run N (number of nodes) times


    //recursive function to construct shortest path from source to chosen node
    //Returns string of shortest path
    string makePath(int[] parent, int index, string shortestPath, int source)
    {
        //Note: parent[] starts at destination and ends with source node
        // Base Case : If index is source node
        if (parent[index] == -1)
        {
            shortestPath = source + " " + shortestPath;
            return shortestPath;
        }

        //else add next node to path
        shortestPath = index + " " + shortestPath;
        return makePath(parent, parent[index], shortestPath, source);
    }


    //Returns array of shortest distance from source to node
    //Given adjacency matrix, number of nodes, and source index
    int[] dijkstra(int[,] matrix, int nodes, int source)
    {
        int[] dist = new int[nodes]; //holds the temporary (or working) shortest distance from source to each node
        bool[] hasBeenChecked = new bool[nodes];
        int[] parent = new int[nodes]; //holds for each node the "parent" node which is the shortest distance node to it
        string shortestPath = null; //string of indices giving shortest path from source to chosen node

        for (int i = 0; i < nodes; i++)
        {
            parent[i] = -1;
            dist[i] = int.MaxValue; //basically setting each dist to node as infinity
            hasBeenChecked[i] = false;
        }

        dist[source] = 0; //distance of source to itself is 0

        for (int l = 0; l < nodes; l++)
        {

            //select node with shortest distance from source that has not been checked
            int minDist = int.MaxValue;
            int minDistIndex = -1;
            //getting index of node with minimum distance
            for (int i = 0; i < nodes; i++)
            {
                if (hasBeenChecked[i] == false)
                {
                    if (dist[i] <= minDist)
                    {
                        minDist = dist[i];
                        minDistIndex = i;
                    }
                }
            }
            hasBeenChecked[minDistIndex] = true;

            //update dist[] based on current minimum dist node and surrounding distances
            for (int i = 0; i < nodes; i++)
            {
                if (hasBeenChecked[i] == false && matrix[minDistIndex, i] != 0)
                {
                    //if sum of (minDistIndex and distance to adjacent node)
                    //is less than temporary shortest distance to node stored in dist
                    //then replace that value with our sum
                    if ((dist[minDistIndex] + matrix[minDistIndex, i]) < dist[i])
                    {
                        parent[i] = minDistIndex; //when find a shorter dist "parent" node within shortest dist tree to our cur node
                                                  //give our cur node represented by index of parent[] the new "parent" node
                        dist[i] = (dist[minDistIndex] + matrix[minDistIndex, i]);
                    }
                }
            }
        }
        //With Dijkstra run completed, dist[] stores permanent values of minimum distance from source to each particular node
        //parent[] will hold for each node the shortest dist "parent node within shortest dist tree
        for (int i = 0; i < numNodes; i++)
        {
            Debug.Log("Shortest path from source " + source + " to " + i + ": " + makePath(parent, i, shortestPath, source));
        }

        return dist;
    }
}
